<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        class Pool {
    constructor(runTask, limit) {
        this.runTask = runTask;
        this.limit = limit;
        this.queue = [];
        this.processing = [];
    }
    enqueue(task) {
        return new Promise((resolve, reject) => {
            this.queue.push({
                task,
                resolve,
                reject
            });
            this.check();
        });
    }
    run(item) {
        this.queue = this.queue.filter(v => v !== item);
        this.processing.push(item);
        this.runTask(item.task).then(() => {
            this.processing = this.processing.filter(v => v !== item);
            item.resolve();
            this.check();
        }, err => item.reject(err));
    }
    check() {
        const processingNum = this.processing.length;
        const availableNum = this.limit - processingNum;
        this.queue.slice(0, availableNum).forEach(item => {
            this.run(item);
        });
    }
}

const chunk = new Blob()
const data = [
    { chunk, index: 0 },
    { chunk, index: 1 },
    { chunk, index: 2 },
    { chunk, index: 3 },
    { chunk, index: 4 },
    { chunk, index: 5 }
]

const taskPromise = (item) => {
    console.log('taskPromise: item', item)
    return Promise.resolve(item)
     
}

const pool = new Pool(taskPromise, 2)

data.forEach(item => {
    pool.enqueue(item)
})





class Spider extends EventEmitter {
    constructor(options) {
        super();
        this.init(options);
    }
    init(options) {
        this.tasks = Array.from(new Set(options.tasks));
        this.errors = []; // 请求失败 大于 预设次数
        this.result = []; // 结果数据
        this.maxError = options.maxError || 5;
        this.limit = options.limit || 5;
        this.listenEvens();
        this.runTask(this.tasks, this.dispatchRequest.bind(this), this.limit);
    }

    transformationTask() {
        this.taskQueue = this.tasks.map(item => {
            if (typeof item !== 'object') {
                return { item, count: 1 };
            }
            else {
                return item;
            }
        });
    }
    checkParam(options) {
        const URL = /(http|https):\/\/([\w.]+\/?)\S*/;
        if (!options.url) {
            console.error('没有传递需要爬取的接口地址');
            return false;
        }
        if (URL.test(options.url)) {
            console.error('传递的链接有问题');
            return false;
        }
        return true;
    }
    listenEvens() {
        this.on('fetchSuccess', (data) => {
            this.result.push(data);
        });
        this.on('fetchFails', (taskItem) => {
            this.errors.push(taskItem);
        });
    }

    runTask(tasks, handle, limit) {
        const pool = new Pool(handle, limit);
        while (tasks.length) {
            pool.enqueue(tasks.shift());
        }
    }
    urlGenerator({ id }) {
        return `https://juejin.cn/user/${id}/posts`;
    }
    dispatchRequest(taskItem) {
        const url = this.urlGenerator(taskItem)
        return fetch(url)
            .then((res) => res.text())
            .then((body) => {
              this.emit('fetchSuccess', body, taskItem);
            })
            .catch((err) => {
              this.emit('fetchFails', taskItem);
            // this.handleError(taskItem)
           });
    }
    handleError(taskItem) {
        taskItem.count++;
        if (taskItem.count < this.maxError) {
            this.tasks.push(taskItem);
        }
        else {
            this.emit('fetchFails', taskItem.id);
        }
    }
}
let Avatar = new Spider({
    tasks: usrList,
    handle: 
});
Avatar.on('fetchSuccess', (html, item) => {
    let $ = cheerio.load(html);
    let avatar = $(".user-info-block .avatar")[0].attribs["data-src"];
    console.dir(avatar);
    // let name = fetch(avatar)
    //     .then((res) => res.buffer())
    //     .then((buffer) => {
    //     fs.writeFile(`../images/${item.id}.jpg`, buffer, (err) => {
    //         if (err)
    //             throw err;
    //         console.log('文件已被保存');
    //     });
    // });
    // .then(type => console.log(type))
    console.dir(avatar);
});
Avatar.on('fetchFails', (item) => {
    console.log(item)
    // let versionText = item + '\n';
    // fs.appendFileSync('../images/错误日志.txt', versionText);
});


    </script>
</body>
</html>